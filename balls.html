<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Balls Chaos</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0d0d15;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-size: 14px;
            text-shadow: 0 0 3px #000;
            pointer-events: none;
            z-index: 100;
        }
        #event-log {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px #000;
            text-align: center;
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="stats"></div>
    <div id="event-log"></div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statsDiv = document.getElementById('stats');
        const eventLogDiv = document.getElementById('event-log');

        // Config - feel free to adjust
        const config = {
            initialBallCount: 30,
            minRadius: 10,
            maxRadius: 30,
            minSpeed: 1,
            maxSpeed: 5,
            gravity: 0.1,
            friction: 0.99,
            explosionChance: 0.3,
            growChance: 0.3,
            mergeChance: 0.4,
            trailChance: 0.5,
            eventInterval: 20000, // 20 seconds
            maxBalls: 150 // Limit to prevent performance issues
        };

        // Game state
        let balls = [];
        let hazards = [];
        let stats = {
            biggestBall: 0,
            longestBounceStreak: 0,
            totalCollisions: 0,
            eventHistory: []
        };
        let gravitySetting = config.gravity;
        let lastEventTime = 0;
        let timeScale = 1;
        let attractorMode = false;
        let attractorPosition = { x: 0, y: 0 };

        // Set canvas size to window dimensions
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Generate random values
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(random(min, max));
        }

        // Color utilities
        function randomColor() {
            const hue = Math.floor(Math.random() * 360);
            return `hsl(${hue}, 100%, 70%)`;
        }

        function randomNeonColor() {
            const neonColors = [
                '#ff00ff', // Magenta
                '#00ffff', // Cyan
                '#ff0099', // Pink
                '#33ff00', // Lime
                '#ff3300', // Orange
                '#ffff00', // Yellow
                '#00ff99', // Turquoise
                '#9900ff'  // Purple
            ];
            return neonColors[Math.floor(Math.random() * neonColors.length)];
        }

        // Ball class
        class Ball {
            constructor(x, y, radius) {
                this.x = x || random(radius, canvas.width - radius);
                this.y = y || random(radius, canvas.height - radius);
                this.radius = radius || random(config.minRadius, config.maxRadius);
                
                const angle = random(0, Math.PI * 2);
                const speed = random(config.minSpeed, config.maxSpeed);
                
                this.velocity = {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                };
                
                this.color = randomNeonColor();
                this.shadowBlur = this.radius * 0.8;
                this.bounceStreak = 0;
                this.collisions = 0;
                this.age = 0;
                this.trailLength = Math.random() > config.trailChance ? 0 : randomInt(5, 20);
                this.trail = [];
                this.mass = this.radius * this.radius * 0.01;
                this.mood = 'neutral'; // neutral, happy, angry
                this.squish = { x: 1, y: 1 };
                this.willExplode = Math.random() < config.explosionChance;
                this.willGrow = !this.willExplode && Math.random() < config.growChance;
                this.canMerge = Math.random() < config.mergeChance;
                this.lifespan = this.willExplode ? randomInt(300, 800) : -1;
            }

            update() {
                // Age the ball
                this.age++;
                
                // Time scaling effect
                const timeStep = timeScale;
                
                // Apply gravity
                this.velocity.y += gravitySetting * timeStep;
                
                // Apply attractor if active
                if (attractorMode) {
                    const dx = attractorPosition.x - this.x;
                    const dy = attractorPosition.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const force = 0.5 / (distance + 50);
                    
                    this.velocity.x += dx * force * timeStep;
                    this.velocity.y += dy * force * timeStep;
                }
                
                // Apply friction
                this.velocity.x *= config.friction;
                this.velocity.y *= config.friction;
                
                // Update position
                this.x += this.velocity.x * timeStep;
                this.y += this.velocity.y * timeStep;
                
                // Bounce off walls
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.velocity.x = Math.abs(this.velocity.x);
                    this.onBounce();
                } else if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.velocity.x = -Math.abs(this.velocity.x);
                    this.onBounce();
                }
                
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.velocity.y = Math.abs(this.velocity.y);
                    this.onBounce();
                } else if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.velocity.y = -Math.abs(this.velocity.y);
                    this.onBounce();
                }
                
                // Update trail
                if (this.trailLength > 0) {
                    this.trail.unshift({ x: this.x, y: this.y, radius: this.radius });
                    if (this.trail.length > this.trailLength) {
                        this.trail.pop();
                    }
                }
                
                // Update squish effect
                this.squish.x += (1 - this.squish.x) * 0.2;
                this.squish.y += (1 - this.squish.y) * 0.2;
                
                // Check explosion
                if (this.willExplode && this.age >= this.lifespan) {
                    this.explode();
                }
                
                // Grow if set to grow
                if (this.willGrow && this.age % 100 === 0 && this.radius < config.maxRadius * 2) {
                    this.radius += 0.5;
                    // Update biggest ball stat
                    if (this.radius > stats.biggestBall) {
                        stats.biggestBall = this.radius;
                    }
                }
                
                // Mood affects color
                if (this.mood === 'angry') {
                    this.color = '#ff3300'; // Red when angry
                    // Angry balls move faster
                    if (Math.random() < 0.1) {
                        const boost = 1.05;
                        this.velocity.x *= boost;
                        this.velocity.y *= boost;
                    }
                } else if (this.mood === 'happy') {
                    this.color = '#33ff00'; // Green when happy
                }
                
                // Return to neutral mood over time
                if (this.mood !== 'neutral' && Math.random() < 0.01) {
                    this.mood = 'neutral';
                    this.color = randomNeonColor();
                }
            }
            
            onBounce() {
                this.bounceStreak++;
                if (this.bounceStreak > stats.longestBounceStreak) {
                    stats.longestBounceStreak = this.bounceStreak;
                }
                
                // Squish effect
                const impactX = Math.abs(this.velocity.x);
                const impactY = Math.abs(this.velocity.y);
                
                if (impactX > impactY) {
                    this.squish.x = 0.7;
                    this.squish.y = 1.3;
                } else {
                    this.squish.x = 1.3;
                    this.squish.y = 0.7;
                }
                
                // Chance to change mood
                if (Math.random() < 0.1) {
                    if (Math.random() < 0.5) {
                        this.mood = 'angry';
                    } else {
                        this.mood = 'happy';
                    }
                }
            }
            
            explode() {
                // Create 3-5 smaller balls
                const numFragments = randomInt(3, 6);
                const fragmentSize = this.radius / Math.sqrt(numFragments);
                
                for (let i = 0; i < numFragments; i++) {
                    if (balls.length < config.maxBalls) {
                        const angle = (i / numFragments) * Math.PI * 2;
                        const newBall = new Ball(
                            this.x + Math.cos(angle) * this.radius * 0.5,
                            this.y + Math.sin(angle) * this.radius * 0.5,
                            fragmentSize
                        );
                        
                        // Give velocity based on explosion direction
                        newBall.velocity.x = this.velocity.x + Math.cos(angle) * 5;
                        newBall.velocity.y = this.velocity.y + Math.sin(angle) * 5;
                        
                        balls.push(newBall);
                    }
                }
                
                // Remove this ball
                const index = balls.indexOf(this);
                if (index > -1) {
                    balls.splice(index, 1);
                }
                
                // Create explosion effect
                createExplosion(this.x, this.y, this.radius);
            }
            
            draw() {
                // Draw trail
                if (this.trailLength > 0) {
                    for (let i = 0; i < this.trail.length; i++) {
                        const t = this.trail[i];
                        const alpha = 1 - (i / this.trailLength);
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, t.radius * alpha, 0, Math.PI * 2);
                        ctx.fillStyle = this.color + Math.floor(alpha * 60).toString(16).padStart(2, '0');
                        ctx.fill();
                    }
                }
                
                // Draw ball
                ctx.beginPath();
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.squish.x, this.squish.y);
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.restore();
                
                ctx.shadowColor = this.color;
                ctx.shadowBlur = this.shadowBlur;
                ctx.fillStyle = this.color;
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Draw rim highlight
                ctx.beginPath();
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.squish.x, this.squish.y);
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.restore();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw countdown indicator if about to explode
                if (this.willExplode && this.lifespan - this.age < 100) {
                    const countdown = 1 - ((this.lifespan - this.age) / 100);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.8, 0, Math.PI * 2 * countdown);
                    ctx.strokeStyle = 'rgba(255, 50, 50, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
            
            checkCollision(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDistance = this.radius + other.radius;
                
                if (distance < minDistance) {
                    stats.totalCollisions++;
                    this.collisions++;
                    other.collisions++;
                    
                    // Reset bounce streak on collision
                    this.bounceStreak = 0;
                    other.bounceStreak = 0;
                    
                    // Calculate collision response
                    const angle = Math.atan2(dy, dx);
                    const sin = Math.sin(angle);
                    const cos = Math.cos(angle);
                    
                    // Rotate velocities
                    const vx1 = this.velocity.x * cos + this.velocity.y * sin;
                    const vy1 = this.velocity.y * cos - this.velocity.x * sin;
                    const vx2 = other.velocity.x * cos + other.velocity.y * sin;
                    const vy2 = other.velocity.y * cos - other.velocity.x * sin;
                    
                    // Calculate new velocities (conservation of momentum)
                    const m1 = this.mass;
                    const m2 = other.mass;
                    const v1 = ((m1 - m2) * vx1 + 2 * m2 * vx2) / (m1 + m2);
                    const v2 = ((m2 - m1) * vx2 + 2 * m1 * vx1) / (m1 + m2);
                    
                    // Rotate velocities back
                    this.velocity.x = v1 * cos - vy1 * sin;
                    this.velocity.y = vy1 * cos + v1 * sin;
                    other.velocity.x = v2 * cos - vy2 * sin;
                    other.velocity.y = vy2 * cos + v2 * sin;
                    
                    // Move balls apart to prevent sticking
                    const overlap = minDistance - distance;
                    const moveX = (overlap / 2) * cos;
                    const moveY = (overlap / 2) * sin;
                    
                    this.x += moveX;
                    this.y += moveY;
                    other.x -= moveX;
                    other.y -= moveY;
                    
                    // Squish effect
                    this.squish.x = 0.8 + Math.abs(cos) * 0.4;
                    this.squish.y = 0.8 + Math.abs(sin) * 0.4;
                    other.squish.x = 0.8 + Math.abs(cos) * 0.4;
                    other.squish.y = 0.8 + Math.abs(sin) * 0.4;
                    
                    // Check for merge
                    if (this.canMerge && other.canMerge && Math.random() < 0.1 && balls.length > 10) {
                        this.merge(other);
                        return true;
                    }
                    
                    // Mood effect
                    if (this.collisions > 10 && Math.random() < 0.3) {
                        this.mood = 'angry';
                    }
                    
                    // Create collision effect
                    createCollisionEffect((this.x + other.x) / 2, (this.y + other.y) / 2);
                    
                    return true;
                }
                return false;
            }
            
            merge(other) {
                // Calculate new properties based on both balls
                const totalArea = Math.PI * this.radius * this.radius + Math.PI * other.radius * other.radius;
                const newRadius = Math.sqrt(totalArea / Math.PI);
                
                // Calculate weighted average for velocity
                const m1 = this.mass;
                const m2 = other.mass;
                const totalMass = m1 + m2;
                
                const newVelocity = {
                    x: (this.velocity.x * m1 + other.velocity.x * m2) / totalMass,
                    y: (this.velocity.y * m1 + other.velocity.y * m2) / totalMass
                };
                
                // Create new merged ball
                const newBall = new Ball(
                    (this.x * m1 + other.x * m2) / totalMass,
                    (this.y * m1 + other.y * m2) / totalMass,
                    newRadius
                );
                
                newBall.velocity = newVelocity;
                newBall.color = randomNeonColor();
                newBall.trailLength = Math.max(this.trailLength, other.trailLength);
                newBall.shadowBlur = newRadius * 1.5;
                
                // Remove the original balls
                const index1 = balls.indexOf(this);
                const index2 = balls.indexOf(other);
                
                if (index1 > -1) balls.splice(index1, 1);
                if (index2 > -1 && index2 > index1) balls.splice(index2 - 1, 1);
                else if (index2 > -1) balls.splice(index2, 1);
                
                // Add the new merged ball
                balls.push(newBall);
                
                // Update biggest ball stat
                if (newRadius > stats.biggestBall) {
                    stats.biggestBall = newRadius;
                }
                
                // Log merge event
                logEvent("Mega Ball Formed! (Size: " + Math.floor(newRadius) + ")");
            }
        }

        // Hazard class (for obstacles)
        class Hazard {
            constructor(type) {
                this.type = type || 'spinner';
                this.x = random(50, canvas.width - 50);
                this.y = random(50, canvas.height - 50);
                this.radius = random(30, 80);
                this.angle = 0;
                this.rotationSpeed = random(0.01, 0.05);
                this.color = randomNeonColor();
                this.points = randomInt(3, 8);
                this.lifespan = randomInt(500, 1000);
                this.age = 0;
            }
            
            update() {
                this.age++;
                this.angle += this.rotationSpeed * timeScale;
                
                // Remove if past lifespan
                if (this.age >= this.lifespan) {
                    const index = hazards.indexOf(this);
                    if (index > -1) {
                        hazards.splice(index, 1);
                    }
                }
                
                // Check for ball collisions
                for (let i = 0; i < balls.length; i++) {
                    const ball = balls[i];
                    const dx = ball.x - this.x;
                    const dy = ball.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (this.type === 'spinner') {
                        // Check if ball hits any spike
                        const spikeTipRadius = this.radius * 1.5;
                        for (let j = 0; j < this.points; j++) {
                            const pointAngle = this.angle + (j / this.points) * Math.PI * 2;
                            const tipX = this.x + Math.cos(pointAngle) * spikeTipRadius;
                            const tipY = this.y + Math.sin(pointAngle) * spikeTipRadius;
                            
                            const dtx = ball.x - tipX;
                            const dty = ball.y - tipY;
                            const tipDistance = Math.sqrt(dtx * dtx + dty * dty);
                            
                            if (tipDistance < ball.radius) {
                                // Ball hit spike - apply force away and damage
                                const forceAngle = Math.atan2(dty, dtx);
                                ball.velocity.x += Math.cos(forceAngle) * 5;
                                ball.velocity.y += Math.sin(forceAngle) * 5;
                                
                                // Chance to explode
                                if (Math.random() < 0.3) {
                                    ball.explode();
                                }
                                
                                createExplosion(tipX, tipY, ball.radius * 0.5);
                                break;
                            }
                        }
                    } else if (this.type === 'blackhole') {
                        // Black hole pulls balls in
                        if (distance < this.radius * 3) {
                            const force = 0.2 * (1 - distance / (this.radius * 3));
                            const angle = Math.atan2(dy, dx);
                            
                            ball.velocity.x -= Math.cos(angle) * force * timeScale;
                            ball.velocity.y -= Math.sin(angle) * force * timeScale;
                            
                            // If ball gets too close, absorb it
                            if (distance < this.radius * 0.7) {
                                this.radius += ball.radius * 0.2;
                                
                                // Create absorption effect
                                createAbsorptionEffect(ball.x, ball.y, ball.radius);
                                
                                // Remove the ball
                                balls.splice(i, 1);
                                i--;
                                
                                logEvent("Ball absorbed by Black Hole!");
                            }
                        }
                    }
                }
            }
            
            draw() {
                if (this.type === 'spinner') {
                    // Draw spinner hazard
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    
                    // Draw spikes
                    for (let i = 0; i < this.points; i++) {
                        const angle = (i / this.points) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(
                            Math.cos(angle) * this.radius * 1.5,
                            Math.sin(angle) * this.radius * 1.5
                        );
                        ctx.lineWidth = 5;
                        ctx.strokeStyle = this.color;
                        ctx.shadowColor = this.color;
                        ctx.shadowBlur = 15;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                    
                    // Draw center
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    ctx.restore();
                } else if (this.type === 'blackhole') {
                    // Draw black hole
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.radius * 2
                    );
                    gradient.addColorStop(0, 'black');
                    gradient.addColorStop(0.7, 'rgba(50, 0, 50, 0.8)');
                    gradient.addColorStop(1, 'rgba(50, 0, 50, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Draw accretion disk
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 1.2, 0, Math.PI * 2);
                    ctx.lineWidth = this.radius * 0.4;
                    ctx.strokeStyle = 'rgba(255, 100, 255, 0.3)';
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
        }

        // Visual effects
        function createExplosion(x, y, radius) {
            const particles = [];
            const particleCount = Math.floor(radius);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = random(1, 5);
                
                particles.push({
                    x: x,
                    y: y,
                    radius: random(1, 4),
                    color: randomNeonColor(),
                    velocity: {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed
                    },
                    lifespan: randomInt(20, 40),
                    age: 0
                });
            }
            
            // Draw explosion particles
            const drawExplosion = function() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.age++;
                    
                    if (p.age >= p.lifespan) {
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    const alpha = 1 - p.age / p.lifespan;
                    p.x += p.velocity.x * timeScale;
                    p.y += p.velocity.y * timeScale;
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                if (particles.length > 0) {
                    requestAnimationFrame(drawExplosion);
                }
            };
            
            drawExplosion();
        }
        
        function createCollisionEffect(x, y) {
            // Draw ripple effect
            const ripples = [];
            ripples.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: random(20, 40),
                speed: random(1, 2),
                color: `rgba(255, 255, 255, ${random(0.3, 0.7)})`,
                age: 0
            });
            
            const drawRipple = function() {
                for (let i = ripples.length - 1; i >= 0; i--) {
                    const r = ripples[i];
                    r.radius += r.speed * timeScale;
                    r.age++;
                    
                    if (r.radius >= r.maxRadius) {
                        ripples.splice(i, 1);
                        continue;
                    }
                    
                    const alpha = 1 - r.radius / r.maxRadius;
                    
                    ctx.beginPath();
                    ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = r.color.replace(')', `, ${alpha})`);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                if (ripples.length > 0) {
                    requestAnimationFrame(drawRipple);
                }
            };
            
            drawRipple();
        }
        
        function createAbsorptionEffect(x, y, radius) {
            const particles = [];
            const particleCount = Math.floor(radius * 2);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = random(0, radius);
                
                particles.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    targetX: x,
                    targetY: y,
                    radius: random(1, 3),
                    color: randomNeonColor(),
                    speed: random(0.05, 0.1),
                    lifespan: randomInt(20, 30),
                    age: 0
                });
            }
            
            const drawAbsorption = function() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.age++;
                    
                    if (p.age >= p.lifespan) {
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    // Move towards target
                    const dx = p.targetX - p.x;
                    const dy = p.targetY - p.y;
                    p.x += dx * p.speed * timeScale;
                    p.y += dy * p.speed * timeScale;
                    
                    const alpha = 1 - p.age / p.lifespan;
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 5;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                if (particles.length > 0) {
                    requestAnimationFrame(drawAbsorption);
                }
            };
            
            drawAbsorption();
        }

        // Event system
        function triggerRandomEvent() {
            const events = [
                'reverseGravity',
                'addBalls',
                'addHazard',
                'colorShift',
                'slowMotion',
                'speedUp',
                'ballsGrow',
                'attractorMode',
                'massExplosion'
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            
            switch(event) {
                case 'reverseGravity':
                    gravitySetting = -gravitySetting;
                    logEvent("Gravity Reversed!");
                    break;
                    
                case 'addBalls':
                    const count = randomInt(5, 15);
                    for (let i = 0; i < count; i++) {
                        if (balls.length < config.maxBalls) {
                            balls.push(new Ball());
                        }
                    }
                    logEvent(`${count} New Balls Added!`);
                    break;
                    
                case 'addHazard':
                    const hazardType = Math.random() < 0.5 ? 'spinner' : 'blackhole';
                    hazards.push(new Hazard(hazardType));
                    logEvent(`${hazardType === 'spinner' ? 'Spinner' : 'Black Hole'} Appeared!`);
                    break;
                    
                case 'colorShift':
                    balls.forEach(ball => {
                        ball.color = randomNeonColor();
                    });
                    logEvent("Color Shift!");
                    break;
                    
                case 'slowMotion':
                    timeScale = 0.3;
                    setTimeout(() => {
                        timeScale = 1;
                    }, 5000);
                    logEvent("Slow Motion!");
                    break;
                    
                case 'speedUp':
                    timeScale = 2;
                    setTimeout(() => {
                        timeScale = 1;
                    }, 5000);
                    logEvent("Speed Up!");
                    break;
                    
                case 'ballsGrow':
                    balls.forEach(ball => {
                        ball.radius *= 1.5;
                        if (ball.radius > config.maxRadius * 3) {
                            ball.radius = config.maxRadius * 3;
                        }
                    });
                    logEvent("Super Size!");
                    break;
                    
                case 'attractorMode':
                    attractorMode = true;
                    attractorPosition.x = canvas.width / 2;
                    attractorPosition.y = canvas.height / 2;
                    setTimeout(() => {
                        attractorMode = false;
                    }, 8000);
                    logEvent("Gravity Well Activated!");
                    break;
                    
                case 'massExplosion':
                    // Select random balls to explode
                    const explodeCount = Math.floor(balls.length * 0.3);
                    const indicesToExplode = [];
                    
                    while (indicesToExplode.length < explodeCount) {
                        const idx = Math.floor(Math.random() * balls.length);
                        if (!indicesToExplode.includes(idx)) {
                            indicesToExplode.push(idx);
                        }
                    }
                    
                    // Sort in reverse order to avoid index shifting issues
                    indicesToExplode.sort((a, b) => b - a);
                    
                    for (const idx of indicesToExplode) {
                        const ball = balls[idx];
                        createExplosion(ball.x, ball.y, ball.radius);
                        balls.splice(idx, 1);
                    }
                    logEvent("Chain Reaction!");
                    break;
            }
            
            lastEventTime = Date.now();
            stats.eventHistory.push(event);
            
            // Limit event history
            if (stats.eventHistory.length > 10) {
                stats.eventHistory.shift();
            }
        }
        
        function logEvent(message) {
            eventLogDiv.textContent = message;
            eventLogDiv.style.opacity = 1;
            
            // Fade out after 3 seconds
            setTimeout(() => {
                eventLogDiv.style.opacity = 0;
            }, 3000);
        }

        // Create initial balls
        function initialize() {
            balls = [];
            hazards = [];
            
            for (let i = 0; i < config.initialBallCount; i++) {
                balls.push(new Ball());
            }
            
            // Add initial hazard
            if (Math.random() < 0.5) {
                hazards.push(new Hazard());
            }
            
            lastEventTime = Date.now();
        }

        // Main animation loop
        function animate() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background with subtle gradient
            const bgGradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width
            );
            bgGradient.addColorStop(0, '#111122');
            bgGradient.addColorStop(1, '#080812');
            
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid lines
            ctx.beginPath();
            for (let x = 0; x < canvas.width; x += 100) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = 0; y < canvas.height; y += 100) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.strokeStyle = 'rgba(50, 50, 100, 0.1)';
            ctx.stroke();
            
            // Update and draw hazards
            for (let i = 0; i < hazards.length; i++) {
                hazards[i].update();
                hazards[i].draw();
            }
            
            // Update and draw all balls
            for (let i = 0; i < balls.length; i++) {
                balls[i].update();
            }
            
            // Check for collisions
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    balls[i].checkCollision(balls[j]);
                }
            }
            
            // Draw balls after all updates
            for (let i = 0; i < balls.length; i++) {
                balls[i].draw();
            }
            
            // Check if it's time for a random event
            const currentTime = Date.now();
            if (currentTime - lastEventTime >= config.eventInterval) {
                triggerRandomEvent();
            }
            
            // Update stats display
            statsDiv.innerHTML = `
                Balls: ${balls.length}<br>
                FPS: ${Math.round(fps)}<br>
                Biggest Ball: ${Math.round(stats.biggestBall)}<br>
                Collisions: ${stats.totalCollisions}
            `;
            
            // Draw attractor position if active
            if (attractorMode) {
                ctx.beginPath();
                ctx.arc(attractorPosition.x, attractorPosition.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fill();
                
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x1 = attractorPosition.x + Math.cos(angle) * 20;
                    const y1 = attractorPosition.y + Math.sin(angle) * 20;
                    const x2 = attractorPosition.x + Math.cos(angle) * 40;
                    const y2 = attractorPosition.y + Math.sin(angle) * 40;
                    
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            requestAnimationFrame(animate);
            
            // Calculate FPS
            frameCount++;
            const elapsed = (Date.now() - lastFpsUpdate) / 1000;
            if (elapsed >= 1) {
                fps = frameCount / elapsed;
                frameCount = 0;
                lastFpsUpdate = Date.now();
            }
        }

        // FPS tracking
        let fps = 60;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        
        // Initialize and start animation
        initialize();
        animate();
        
        // Enable mobile support (resizing and basic touch events)
        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const x = touch.clientX;
            const y = touch.clientY;
            
            // Add a ball on touch
            if (balls.length < config.maxBalls) {
                const newBall = new Ball(x, y);
                newBall.velocity.x *= 2;
                newBall.velocity.y *= 2;
                balls.push(newBall);
            }
        });
        
        // Optional: Add a click event for desktop users
        canvas.addEventListener('click', function(e) {
            const x = e.clientX;
            const y = e.clientY;
            
            // Add a ball on click
            if (balls.length < config.maxBalls) {
                const newBall = new Ball(x, y);
                newBall.velocity.x *= 2;
                newBall.velocity.y *= 2;
                balls.push(newBall);
            }
        });
    </script>
</body>
</html>
